% RA, 2020-10-17

classdef Player
	% Interpret `input` as an array of 5 input signals
	properties
		response1
		response2
		response3
	end
	
	methods
		function self = Player()
			self.response1 = rand;
			self.response2 = rand;
			self.response3 = rand;
			
			% There could be a problem if 
			% self.response1 is initially almost zero
			%
			% This may be interpreted as "ready".
		end
		
		function self = process(self, input)
			assert(length(input) == 5)
			shared_constants;
			
			b1 = input(1);
			
			if (b1 > 0.5)
				% This means I need to build a response
				
				% However need to self-check first
				if 
				end
			
				b2 = input(2);
				b3 = input(3);
				b4 = input(4);
				b5 = input(5);

				sticks = (b2 * 8) + (b3 * 4) + (b4 * 2) + (b5 * 1);
				disp(['Player: I see ' num2str(sticks) ' sticks']);

				if (sticks < 0.6)
					% Assume zero sticks
					target = [1, [0, 0]];
					disp('Player: I see no sticks');
				elseif (15.4 <= sticks)
					% Assume over 15 sticks
					target = [1, [0, 0]];
					disp('Player: too many sticks');
				else
					% Try to leave 1, 5, 9, 13 sticks
					sticks = round(sticks);
					
					% See Take Leave
					% 15    2   13
					% 14    1   13
					% 13    1   12
					% 12    3    9
					% 11    2    9
					% 10    1    9
					%  9    1    8
					%  8    3    5 
					%  7    2    5
					%  6    1    5
					%  5    1    4
					%  4    3    1
					%  3    2    1
					%  2    1    1
					%  1    1    0
					%  0    0    0

					while sticks > 4
						sticks = sticks - 4;
					end

					assert((1 <= sticks) & (sticks <= 4))

					if (sticks == 1)
						% No choice but to take
						target = [1, [0, 1]];
					elseif (sticks == 2)
						% Take 1
						target = [1, [0, 1]];
					elseif (sticks == 3)
						% Take 2
						target = [1, [1, 0]];
					elseif (sticks == 4)
						% Take 3
						target = [1, [1, 1]];
					else
						disp('SOMETHING IS WRONG');
					end
				end

			else
				% This means my response has been read
				% I need to turn it off
				
				disp('Player: getting ready');
				
				% Need to wait until those are zero
				% because they will switch on faster 
				% than target1 when returning an answer
				target1 = (self.response2 > ALMOST_ZERO) || (self.response3 > ALMOST_ZERO);
				
				target = [target1, [0, 0]];
			end
			
			FAST = 0.2;
			SLOW = 0.1;
			self.response1 = (1 - SLOW) * self.response1 + SLOW * target(1);
			self.response2 = (1 - FAST) * self.response2 + FAST * target(2);
			self.response3 = (1 - FAST) * self.response3 + FAST * target(3);
		end
	end
	
% 	constants;
% 	
% 	assert(length(input) == 5)
% 	
% 	b1 = input(1);
% 	
	
	
end
